---
layout: subpage
title: CS2103T Module Review
description: NUS CS2103T Module Review
---

In this section, I'm writing my personal take on CS2103T, how I felt about it,
and probably some advice for the juniors who have yet to take this mod too!

I've also left the same [module review](https://nusmods.com/modules/CS2103T/software-engineering)
on NUSMods.

---

_Taken in AY19/20 Sem 2_

_Lecturer: Mr. Akshay Narayan_

**Description:**

This module teaches Software Engineering (SE), one of the more popular
branches in Computer Science, which have the most practical applications
in the industry.

Using the Object-Oriented Programming (OOP) (imperative style), as the
backdrop, many SE principles were introduced to us, throughout the
semester.

Broadly, 5 aspects of SE were covered, and they are; requirements gathering,
software design, implementation, quality assurance, and project management.

Firstly for requirements gathering, we covered some general aspects, like;
prioritising requirements and Non-Functional Requirements, before looking at
a few requirements gathering and requirements specification techniques
(with particular emphasis on User Stories).

For the software design aspect, we studied some general design principles,
like; Abstraction and Coupling, and the various Unified Modelling Language (UML)
modelling tools, including; Class, Activity, and Sequence Diagrams.
Additionally, some common design/architectural patterns and solutions
were covered too.

As for the implementation aspect, it was quite rule-based, where various
principles and best practices which constitutes good code quality were
advocated. Besides code quality, other topics covered, includes;
documentation, error-handling, logging, debugging, defensive programming,
and integration.

As for quality assurance, we focussed mainly on software testing, the
various kinds of tests, like; Unit Testing, Integration Tests, and System
Tests, and how to design effective and efficient test cases.

Finally, for project management, we were taught about VCS and how to use
Git properly, the different SDLC process models, and also some tips on
project planning and teamwork.

**Relationship to CS2030:**

I would say, there is quite a substantial overlap with CS2030.

Most of the SE principles, under the software design aspect, required
some solid understanding of OOP programming.

For example, to draw UML Class diagrams, it is crucial to understand classes,
inheritance and polymorphism.

As another example, to understand the command design pattern, one needs
to first know what polymorphism is.

Besides being more advanced than CS2030, in a theoretical sense, this module
is also more advanced than CS2030, practically.

Throughout the team project, where we worked on a medium-scale codebase,
we had to deal with dozens of Java classes all at once, as compared to only
one/two classes in CS2030.

Also, whilst getting our hands dirty with such a considerably large codebase,
many design decisions had to be made on our own, and making such 'wrong'
decisions would lead to a rippling snowball effect where it would be
increasingly harder to rectify down the road.

**Relationship to CS2040S:**

Although this module was included as a prerequsite, there doesn't seem
to be any overlap with CS2040S.

The SE principles introduced, didn't really involve any specific
knowledge of data structures and algorithms.

Perhaps, during the SE project, some teams might leverage on their CS2040S
knowledge to optimise their code for time and space efficiency.

However, in this module, grading was not based on how optimally code runs, but
rather on the adherance of the SE principles covered in class, and how well
they have been applied.

**Some study tips (my two cents worth):**

Besides the team project where a group of 4-5 work on a medium-scale
codebase, which was the highlight of this module, there was much to study
as well.

I believe you can see through my lengthy description above, that this
module is actually quite theoretical too.

As for the theoretical parts, I suggest literally going through everything
about OOP programming in CS2030 again.

In fact, the first week of the module is dedicated to doing just that, so
you should be fine.

Now, as for the team project, we were allowed to form our own groups
of 4-5 members, however do expect some changes and rearrangments.

For instance in our tutorial class, with 20 people, all groups had only
4 members while there was one group with 5, and the group of 5 had to
thus be split up, so that each group has 5-members.

Personally, I felt that the team project to be quite a useful exposure to
how it would be probably like, in the SE industry, where together with
a team of few others, everyone works on the same codebase, at the
same time.

Also, the project provided us an good avenue to apply all the useful
SE principles taught to us in class.

I felt the complexity of the project and the team-size was just nice,
to helping us apply most of these principles.

Grading-wise, the marks were evenly distributed throughout each
aspect of the grading criteria, e.g, product design, implementation,
and documentation, even down to the sub-components and so on.

As such, the grading scheme ended up to be pretty complex.

Also, as others have mentioned, the grading scheme
was not quite clear-cut on how one would go about to secure the
marks, and is mostly subject to the teaching team's discretion.

However, the grading of the project was non bell-curved.

Nonetheless, I urge you not to be drawn away by these circumstances,
and just give your best for this team project, that you might learn
and benefit much from it.

All the best, and hope this helps!

Effort: 7/10

Difficulty: 6/10

Expected Grade: B+

Actual Grade: B
