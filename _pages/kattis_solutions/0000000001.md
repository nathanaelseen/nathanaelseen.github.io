---
layout: subpage
title: All Pairs Shortest Path
description: Discusses the given question, the intuition behind the solution, and the solution itself
---

In this section, I will discuss the given question, the intuition behind the solution, and the
solution itself.

_(Adapted from [Kattis](https://open.kattis.com/problems/allpairspath), license:
[CC BY-SA 3.0](https://creativecommons.org/licenses/by-sa/3.0/).)_

---

**Input:**

The input consists of several test cases. Each test case starts with a line with three
non-negative integers, $$1 \leqslant n \leqslant 150$$, $$0 \leqslant m \leqslant 5000$$
and $$1 \leqslant q \leqslant 1000$$, separated by single single spaces, where $$n$$ is
the numbers of nodes in the graph, $$m$$ the number of edges and $$q$$ the number of
queries. Nodes are numbered from $$0$$ to $$n - 1$$. Then follow $$m$$ lines, each
line consisting of three (space-separated) integers $$u$$, $$v$$ and $$w$$ indicating
that there is an edge from $$u$$ to $$v$$ in the graph with weight
$$-1000 \leqslant w \leqslant 1000$$. Then follow $$q$$ lines of queries, each
consisting of two node numbers $$u$$ and $$v$$ (separated by a space), asking
for the minimum distance from node $$u$$ to node $$v$$.

Input will be terminated by a line containing ``0 0 0``, this line should not be processed.

**Output:**

For each query, output a single line containing the minimum distance from node
$$u$$ to $$v$$, or the word ``Impossible`` if there is no path from $$u$$ to $$v$$,
or ``-Infinity`` if there are arbitrarily short paths from $$u$$ to $$v$$. Print
a blank line after each test case.

Sample Input 1:
```
4 3 4
0 1 2
1 2 2
3 3 1
0 2
1 2
3 0
3 3
2 1 2
0 1 100
0 1
1 0
0 0 0
```

Sample Output 1:
```
4
2
Impossible
0

100
Impossible
```

[//]: # _**Intuition**_

**Solution (Java)**

```java
public class AllPairsShortestPath {
    public static void main(String[] args) {
        Kattio io = new Kattio(System.in);

        boolean firstTime = true;

        while (true) {
            int n = io.getInt();
            int m = io.getInt();
            int q = io.getInt();

            if (n == 0 && m == 0 && q == 0) {
                break;
            } else {
                if (!firstTime) {
                    io.println();
                } else {
                    firstTime = false;
                }
            }

            int[][] dist = new int[n][n];

            int INF = Integer.MAX_VALUE;
            int NEG_INF = Integer.MIN_VALUE;

            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (i != j) {
                        dist[i][j] = INF;
                    }
                }
            }

            for (int i = 0; i < m; ++i) {
                int u = io.getInt();
                int v = io.getInt();
                int weight = io.getInt();

                if (weight < dist[u][v]) {
                    dist[u][v] = weight;
                }
            }

            for (int k = 0; k < n; ++k) {
                for (int v = 0; v < n; ++v) {
                    for (int w = 0; w < n; ++w) {
                        if ((dist[v][w] > dist[v][k] + dist[k][w]) && (dist[v][k] < INF) && (dist[k][w] < INF)) {
                            dist[v][w] =  dist[v][k] + dist[k][w];
                        }
                    }
                }
            }

            // For neg-cycles
            for (int v = 0; v < n; ++v) {
                for (int w = 0; w < n; ++w) {
                    for (int k = 0; (dist[v][w] != NEG_INF && k < n); ++k) {
                        if ((dist[k][k] < 0) && (dist[v][k] < INF) && (dist[k][w] < INF)) {
                            dist[v][w] = NEG_INF;
                        }
                    }
                }
            }

            for (int i = 0; i < q; ++i) {
                int u = io.getInt();
                int v = io.getInt();

                if (dist[u][v] == INF) {
                    io.println("Impossible");
                } else if (dist[u][v] == NEG_INF) {
                    io.println("-Infinity");
                } else {
                    io.println(dist[u][v]);
                }
            }
        }

        io.flush();
    }
}
```

**Solution (Python)**

```python
from math import inf
firstTime = True
while True:
    n, m, q = map(int, input().split())

    if n == 0 and m == 0 and q == 0:
        break
    else:
        if not firstTime:
            print()
        else:
            firstTime = False

    dist = [[inf for i in range(n)] for j in range(n)]

    for i in range(n):
        for j in range(n):
            if i == j:
                dist[i][j] = 0

    for i in range(m):
        u, v, w = map(int, input().split())
        dist[u][v] = min(dist[u][v], w)

    for k in range(n):
        for v in range(n):
            for w in range(n):
                if dist[v][k] < inf and dist[k][w] < inf:
                    dist[v][w] = min(dist[v][w], dist[v][k] + dist[k][w])

    # Checking neg cycles
    for k in range(n):
        for v in range(n):
            for w in range(n):
                if dist[k][v] != -inf and w < n:
                    if (dist[w][w] < 0 and dist[k][w] < inf
                            and dist[w][v] < inf):
                        dist[k][v] = -inf

    for i in range(q):
        u, v = map(int, input().split())
        w = dist[u][v]

        if w == inf:
            print("Impossible")
        elif w == -inf:
            print("-Infinity")
        else:
            print(w)
```
